# 2020.4.21

## 调整数组顺序使奇数位于偶数前面

使用快排的方式,两个下标，一个朝后走一个朝前走
前下标遇到偶数停下，后下标遇到奇数停下，交换，知道两个下标相遇
时间复杂度O(n)

code

```cpp
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int i = 0, j = nums.size()-1;
        int temp; 
        while (i < j)
        {
            while(i < nums.size() && nums[i] % 2 == 1)
                i++;
            while(j > 0 && nums[j] % 2 == 0)
                j--;
            if(i < j)
            {
                temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp; 
            }    
        }
        return nums;
    }
};
```

## 链表中倒数第k个节点

个人思路：使用一个队列，长度为K，当其中元素数量不足k时直接入队，为k时先弹出第一个再入队一个，最后将队列首部的元素弹出返回即可
code

```cpp
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        queue<ListNode*> NodeQueue;
        ListNode *pRes, *pNode = head;
        while(pNode->next != NULL)
        {
            if(NodeQueue.size() < k)
                NodeQueue.push(pNode);
            else
            {
                NodeQueue.pop();
                NodeQueue.push(pNode);
            }
            pNode = pNode->next;
        }
        if(NodeQueue.size() < k)
            NodeQueue.push(pNode);
        else
        {
            NodeQueue.pop();
            NodeQueue.push(pNode);
        }
        pRes = NodeQueue.front();
        return pRes;
    }
};
```

更好的思路：快慢指针，间隔为k

code

```cpp
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* first= head, *slow = head;
        int i = 0;
        while(first)
        {
            if(i < k)
            {
                first = first->next;
                i++;
            }
            else
            {
                first = first->next;
                slow = slow->next;
            }
        } 
        return slow;
    }
};
```

## 翻转链表

个人思路：三指针(pre node last)很笨的思路

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL, *node = head, *last = NULL;
        if(node == NULL)
            return NULL;
        last = node->next;
        while(last)
        {
            node ->next = pre;
            pre = node;
            node = last;
            last = last->next;
        }
        node ->next = pre;
        return node;
    }
};
```

更好的思路：

- 递归

当传入头结点为NULL或者头结点的next指针为NULL就返回
否则递归调用
翻转流程就是将head->next->next = head;head->next = nullptr;

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;

        ListNode* ans = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return ans;
    }
};
```

- 双指针(个人思路的优化版本)

一个pre，一个curr
当curr不为null时翻转节点，最后返回pre指针

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, *cur = head;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

## 合并两个排序的链表

个人做法：递归方式(理解很简单)
效率不太高

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == NULL)
            return l2;
        else if(l2 == NULL)
            return l1;
        ListNode *pMergedHead = NULL;

        if(l1->val < l2->val)
        {
            pMergedHead = l1;
            pMergedHead->next = mergeTwoLists(l1->next, l2);
        }
        else
        {
            pMergedHead = l2;
            pMergedHead->next = mergeTwoLists(l1, l2->next);
        }
        return pMergedHead;
    }
};
```

更高效的做法：循环做法

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* p = new ListNode(-1);
        ListNode* ret = p;
        while(l1 && l2){
            if(l1 -> val <= l2 -> val){
                p -> next = l1;
                l1 = l1 -> next;
            }
            else{
                p -> next = l2;
                l2 = l2 -> next;
            }
            p = p -> next;
        }
        p -> next = l1 ? l1 : l2;
        return ret -> next;
    }
};
```

## 树的子结构

方法：递归处理

code

```cpp
class Solution {
public:
    bool DoesTree1HaveTree2(TreeNode* A, TreeNode* B) {
        if(B == NULL)
            return true;
        if(A == NULL)
            return false;
        if(A->val != B->val)
            return false;
        return DoesTree1HaveTree2(A->left, B->left) && DoesTree1HaveTree2(A->right, B->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        bool result = false;
        if(A && B)
        {
            if(A->val == B->val)
            {
                result = DoesTree1HaveTree2(A, B);
            }
            if(!result)
                result = isSubStructure(A->left, B);
            if(!result)
                result = isSubStructure(A->right, B);
        }
        return result;
    }
};

```